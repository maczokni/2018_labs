{
    "collab_server" : "",
    "contents" : "library(sf)\nlibrary(tidyverse)\n\nuk_lsoa <- st_read(\"/Users/reka/Dropbox (The University of Manchester)/FMS/appStreet/BoundaryData (2)/england_lsoa_2011.shp\")\n#uk_lsoa <- st_read(\"C:\\\\Users\\\\mllxjrs3\\\\Dropbox (The University of Manchester)\\\\FMS\\\\appStreet\\\\BoundaryData (2)\\\\england_lsoa_2011.shp\")\nclass(uk_lsoa)\nattr(uk_lsoa, \"sf_column\")\nprint(uk_lsoa[9:15], n = 3)\nView(head(uk_lsoa))\nunique(uk_lsoa$name)\nplot(uk_lsoa[4])\n\n#pts <- read.csv(\"/Users/reka/Dropbox (The University of Manchester)/FMS/appStreet/top0.1percentFmsPpl.csv\")\n#pts <- read.csv(\"C:\\\\Users\\\\mllxjrs3\\\\Dropbox (The University of Manchester)\\\\FMS\\\\appStreet\\\\top1percentFmsPpl.csv\")\npts <- read.csv(\"/Users/reka/Dropbox (The University of Manchester)/FMS/appStreet/top1percentFmsPpl.csv\")\npts <- st_as_sf(pts, coords = c(\"lng\", \"lat\"))\npts <- st_set_crs(pts, 4326)\nplot(pts[3])\n\n\nlsoa_WGS84 <- st_transform(uk_lsoa, 4326)\nst_crs(lsoa_WGS84)\n\nst_crs(pts) == st_crs(lsoa_WGS84)\n\nfms_reps_with_lsoa <- st_join(pts, lsoa_WGS84, join = st_within)\nfms_reps_with_lsoa$name.x <- as.character(fms_reps_with_lsoa$name.x)\n\n#remove people with non-person names:\nnonPplNames <- c(\"A Resident\", \n                 \"all seeing eye....\",\n                 \"big hole\",\n                 \"Burnham NAG Chairman\",                                     \n                 \"Campbell Park West NAG\",\n                 \"Community Safety Team\",\n                 \"disability action wyre forest\",\n                 \"Friends Of The Brigg &amp; Lincoln Lines Rail Group\",\n                 \"Hersham Village Society - ESM\",\n                 \"Disgruntled Resident\",\n                 \"Cross Bromley Resident\",\n                 \"Kingston Cycling Campaign\",\n                 \"Liberal Democrat\",                                   \n                 \"Liverpool green party\",\n                 \"Local Resident\",\n                 \"mr mad as hell\",\n                 \"NorthWestTWO Residents&#39; Association\",\n                 \"Mile End Residents\",\n                 \"Ravensbourne Valley Preservation Society\",\n                 \"safety warden\",                                    \n                 \"SBC Customer Service\",\n                 \"Uncle Squishy (Community Action Collective)\",\n                 \"Stockham Park Ranger\", \n                 \"customer service centre\",\n                 \"customer services\",                           \n                 \"Customer Services\"  )\n#but keep ones where it's reasonable to assume it was all reported by 1 person (eg: \"Frank Batt For The Ramsgate Society\", \"Tom Stokes - Spring Vale Focus Team\" or \"streatham mum\")\n\n\nnhood_per_person <- fms_reps_with_lsoa %>%\n  filter(!name.x %in% nonPplNames) %>%\n  filter(!is.na(name.y)) %>%\n  group_by(name.x, name.y, code) %>%\n  count(n=n())\n\n\n  \nnum_nhoods_pp <- nhood_per_person %>%\n  group_by(name.x) %>%\n  count(n=n())\n\n\n\nggplot(num_nhoods_pp, aes(y=n, x = 1, group = 1)) + \n  geom_boxplot() +\n  theme_bw() +\n  ylab(\"Number of neighbourhoods in which \\n a person made FMS reports\") +\n  xlab(\"\")\n\n\noneNhoodOnly <- num_nhoods_pp %>%\n  filter(n < 2)\n\noneNhoodPpl <- nhood_per_person %>%\n  filter(name.x %in% oneNhoodOnly$name.x)\n\nsummary(oneNhoodPpl$n)\n\n\n\n\ndammitKyle <- nhood_per_person %>%\n  filter(name.x==\"Kyle Harrison\")\n\ndammitKyle <- nhood_per_person %>%\n  filter(name.x==\"[AE91] William\")\n\n\nkyleMap <- full_join(lsoa_WGS84, dammitKyle, by = 'code') %>%\n  filter(!is.na(n))\n\nplot(kyleMap[6])\n\n#devtools::install_github(\"tidyverse/ggplot2\") # NB need development version for geom_sf()\nlibrary(ggplot2)\n\n\nggplot() +\n  geom_sf(aes(fill=1, alpha = 0), lsoa_WGS84) + \n  geom_sf(aes(fill = n), data = kyleMap) +\n  scale_fill_gradientn('Number of reports', colours=RColorBrewer::brewer.pal(5,\"RdPu\"), \n                       breaks = scales::pretty_breaks(n = 5)) +\n  labs(fill = \"Number of reports\",\n       title = paste0(\"Range of reports by \", name), \n       subtitle = \"\",\n       caption = \"Contains OS data © Crown copyright and database right (2017) \\n\n       Data from www.fixmystreet.com\") +\n  theme_void()\n\nlistOfNames <- unique(nhood_per_person$name.x)\nfor(name in listOfNames){\n  \n  personDB <- nhood_per_person %>%\n    filter(name.x==name)\n  \n  personMap <- full_join(lsoa_WGS84, personDB, by = 'code') %>%\n    filter(!is.na(n))\n  \n  st_write(personMap, paste0(\"/Users/reka/Dropbox (The University of Manchester)/FMS/appStreet/personRangeMaps/\", gsub(\" \", \"_\", name), \".shp\"))\n  \n}\n\n#What is the spatial overlap between these super guardians? \n\nperson_per_nhood <- nhood_per_person %>%\n  group_by(name.y, code) %>%\n  count(n=n())\n\n\n\nlibrary(rgeos)\nlibrary(rgdal)\n\nkyleMap <- as(kyleMap, 'Spatial')\nsum(gTouches(kyleMap, byid=TRUE), na.rm=TRUE)\n\n\n\n#build classifying vars\n\nlistOfNames <- unique(nhood_per_person$name.x)[1:5]\ndatalist = list()\ni = 1\nfor(name in listOfNames){\n  \n  personDB <- nhood_per_person %>%\n    filter(name.x==name)\n  \n  personMap <- full_join(lsoa_WGS84, personDB, by = 'code') %>%\n    filter(!is.na(n))\n  \n  personMap <- as(personMap, 'Spatial')\n  \n  dat <- data.frame(person_name = name, \n                    connect_score= sum(gTouches(personMap, byid=TRUE), na.rm=TRUE))\n  dat$i <- i  # maybe you want to keep track of which iteration produced it?\n  datalist[[i]] <- dat # add it to your list\n  i = i+1\n}\nclassifying_data = do.call(rbind, datalist)\n\n\nView(head(pts))\n\n\n#CLUSTERS\n\n\n\nlibrary(geosphere)\n\n\nkylePts <- pts %>%\n  filter(name==\"[AE91] William\")\n\nkylePts <- pts %>%\n  filter(name==\"Kyle Harrison\")\n\n# convert data to a SpatialPointsDataFrame object\nkylePts <- as(kylePts, 'Spatial')\n\n# use the distm function to generate a geodesic distance matrix in meters\nmdist <- distm(kylePts)\n\n\n# cluster all points using a hierarchical clustering approach\nhc <- hclust(as.dist(mdist), method=\"complete\")\n\n# define the distance threshold, in this case 900m (a typical value for ‘criminal’ movement in urban environments) (Rossmo 2000).\n#in Rossmo, D.K., 2000. Geographic profiling. Boca Raton, FL: CRC Press.\nd=900\n\n# define clusters based on a tree \"height\" cutoff \"d\" and add them to the SpDataFrame\nkylePts$clust <- cutree(hc, h=d)\n\n\nlibrary(dismo)\n\n# expand the extent of plotting frame\nkylePts@bbox[] <- as.matrix(extend(extent(kylePts),0.001))\n\n# get the centroid coords for each cluster\ncent <- matrix(ncol=2, nrow=max(kylePts$clust))\nfor (i in 1:max(kylePts$clust))\n  # gCentroid from the rgeos package\n  cent[i,] <- gCentroid(subset(kylePts, clust == i))@coords\n\n# use the distm function to generate a geodesic distance matrix in meters\ncdist <- distm(cent)\n\n# compute circles around the centroid coords using a 900m radius\n# from the dismo package\nci <- circles(cent, d=d, lonlat=T)\n\n# plot\nplot(ci@polygons, axes=T)\nplot(kylePts, col=rainbow(max(kylePts$clust))[factor(kylePts$clust)], add=T)\n\n\nnumClust <- max(kylePts$clust)\n\n\n############################################################################\nkylePts@data$clust <- NULL\n\nlibrary(fpc)\nlibrary(dbscan)\nlibrary(factoextra)\n\nkylePts@data$ptnum <- c(1:nrow(kylePts@data))\n\ndf <- as.data.frame(kylePts@coords)\n\nkylePam <- pamk(df)\n\n# expand the extent of plotting frame\nkylePts@bbox[] <- as.matrix(extend(extent(kylePts),0.001))\n\n# get the centroid coords for each cluster\ncent <- kylePam$pamobject$medoids\n\n# from the dismo package\nci <- circles(cent, d=400, lonlat=T)\n\n#merge clusters back to points\nassignclust <- data.frame(t(data.frame((as.list(kylePam$pamobject$clustering)))))\nassignclust <- rownames_to_column(assignclust, \"ptnum\")\nassignclust$ptnum <- gsub(\"X\", \"\", assignclust$ptnum)\nassignclust$ptnum <- as.numeric(assignclust$ptnum)\ncolnames(assignclust)[2] <- \"clust\"\nkylePts@data <- left_join(kylePts@data,assignclust )\n\n\n# plot\nplot(ci@polygons, axes=T)\nplot(kylePts, col=rainbow(max(kylePts$clust))[factor(kylePts$clust)], add=T)\n\n\n\n\nset.seed(123)\ndb <- fpc::dbscan(df, eps = 0.15, MinPts = 3)\ndb_df = t(do.call(rbind, db))\n\nfviz_cluster(db, data = df, stand = FALSE,\n             ellipse = FALSE, show.clust.cent = FALSE,\n             geom = \"point\",palette = \"jco\", ggtheme = theme_classic())\n\n#ugh just do kde\n\n# Calculate a 500 metre margin around the shapefile to ensure the density hotspots aren't cut off on the map plot.\nkylePts <- pts %>%\n  filter(name==\"[AE91] William\")\n\nkylePts <- pts %>%\n  filter(name==\"Kyle Harrison\")\n\n\nmap_padding <- 500\nmap_padding <- c(-map_padding, map_padding,\n                 -map_padding, map_padding)\n\nlibrary(MASS)\n\nkernal_density_estimate = kde2d(kylePts$geometry[[1]][1],\n                                kylePts$geometry[[1]][2],\n                                h=400, # bandwidth\n                                n=500 # gridpoints in each direction\n                                )\n\n\nraster_kde2d = raster(kernal_density_estimate)\n\n\n####################\n#make our df of cluster stuff\n\nlistOfNames <- unique(nhood_per_person$name.x)\ndatalist = list()\nj = 1\nfor(person_name in listOfNames){\n  kylePts <- pts %>%\n    filter(name==person_name)\n  \n  # convert data to a SpatialPointsDataFrame object\n  kylePts <- as(kylePts, 'Spatial')\n  \n  # use the distm function to generate a geodesic distance matrix in meters\n  mdist <- distm(kylePts)\n  \n  # cluster all points using a hierarchical clustering approach\n  hc <- hclust(as.dist(mdist), method=\"complete\")\n  \n  # define the distance threshold, in this case 900m (a typical value for ‘criminal’ movement in urban environments) (Rossmo 2000).\n  #in Rossmo, D.K., 2000. Geographic profiling. Boca Raton, FL: CRC Press.\n  d=900\n  \n  # define clusters based on a tree \"height\" cutoff \"d\" and add them to the SpDataFrame\n  kylePts$clust <- cutree(hc, h=d)\n\n  # get the centroid coords for each cluster\n  cent <- matrix(ncol=2, nrow=max(kylePts$clust))\n  for (i in 1:max(kylePts$clust)){\n    # gCentroid from the rgeos package\n    cent[i,] <- gCentroid(subset(kylePts, clust == i))@coords\n  }\n  # use the distm function to generate a geodesic distance matrix in meters for distance between cluster centroids\n  cdist <- distm(cent)\n  \n  person_nhood <- nhood_per_person %>%\n    filter(name.x==person_name) \n  st_geometry(person_nhood) <- NULL\n  personMap <- full_join(lsoa_WGS84, person_nhood, by = 'code') %>%\n    filter(!is.na(n))\n  personMap <- as(personMap, 'Spatial')\n  \n  datalist[[j]] <- data.frame(person_name = person_name, \n                             num_clusters = max(kylePts$clust),\n                             avg_dist_bw_clusts = mean(cdist),\n                             sd_dist_bw_clusts = sd(cdist),\n                             num_nhoods = num_nhoods_pp$n[num_nhoods_pp$name.x==person_name],\n                             num_reports = fmsWithGender %>%\n                               filter(name==person_name) %>%\n                               nrow(),\n                             mean_per_nhood = mean(person_nhood$n),\n                             sd_per_nhood = sd(person_nhood$n),\n                             connect_score= sum(gTouches(personMap, byid=TRUE), na.rm=TRUE)\n  )\n  j <- j+1\n  print(person_name)\n}\nclassifying_data = do.call(rbind, datalist)\nwrite.csv(classifying_data, file=\"classifying_data.csv\")\n\n\n#NOW USE KMEANS TO CLUSTER\n\n#replace NA in sd col with 0\n\nclassifying_data$sd_dist_bw_clusts <- ifelse(is.na(classifying_data$sd_dist_bw_clusts), 0, classifying_data$sd_dist_bw_clusts)\nclassifying_data$sd_per_nhood <- ifelse(is.na(classifying_data$sd_per_nhood), 0, classifying_data$sd_per_nhood)\n\n# Initialize total within sum of squares error: wss\nwss <- 0\n\n# Look over 1 to 15 possible clusters\nfor (i in 1:15) {\n  # Fit the model: km.out\n  km.out <- kmeans(classifying_data[2:9], centers = i, nstart = 20, iter.max = 50)\n  # Save the within cluster sum of squares\n  wss[i] <- km.out$tot.withinss\n}\n\n# Produce a scree plot\nplot(1:15, wss, type = \"b\", \n     xlab = \"Number of Clusters\", \n     ylab = \"Within groups sum of squares\")\n\n# Select number of clusters\nk <- 4\n\n# Build model with k clusters: km.out\nkm.fms <- kmeans(classifying_data[2:4], centers = k, nstart = 20, iter.max = 50)\n\n# attach back to DB\nclassifying_data$clust <- km.fms$cluster\n\n#check\n\ncluster_4 <- classifying_data %>%\n  filter(clust==4) %>%\n  dplyr::select(person_name)\n\n\nclust4_ppl <- nhood_per_person %>%\n  filter(name.x %in% cluster_4$person_name) \n\nst_geometry(clust4_ppl) <- NULL\nclust4Map <- full_join(lsoa_WGS84, clust4_ppl, by = 'code') %>%\n  filter(!is.na(n))\n\n\nfor(person_name in unique(clust4Map$name.x)){\n  \n  personMap <- clust4Map %>%\n    filter(name.x==person_name)\n  png(filename=paste0(\"/Users/reka/Dropbox (The University of Manchester)/FMS/appStreet/clusters/cluster_4/\", person_name, \".png\"))\n  plot(personMap[6])\n  dev.off()\n}\n\n\n\n########## REFS\n\n\n\n\n\n\n\n#http://www.sthda.com/english/articles/30-advanced-clustering/105-dbscan-density-based-clustering-essentials/\n#http://www.sthda.com/english/articles/25-cluster-analysis-in-r-practical-guide/111-types-of-clustering-methods-overview-and-quick-start-r-code/\n#https://stackoverflow.com/questions/2190756/how-to-count-true-values-in-a-logical-vector\n#https://gis.stackexchange.com/questions/17638/how-to-cluster-spatial-data-in-r\n#https://stackoverflow.com/questions/29402528/append-data-frames-together-in-a-for-loop\n#https://stackoverflow.com/questions/16816032/convert-named-character-vector-to-data-frame\n#https://gis.stackexchange.com/questions/64392/find-clusters-of-points-based-distance-rule",
    "created" : 1516895478216.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "184875196",
    "id" : "79831E7F",
    "lastKnownWriteTime" : 1516288899,
    "last_content_update" : 1516288899,
    "path" : "~/Dropbox (The University of Manchester)/FMS/appStreet/spatial_fms_home.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}